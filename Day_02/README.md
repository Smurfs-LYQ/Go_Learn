#### <center>Day_02</center>

1. 运算符
2. 占位符
3. 数组
4. 切片
5. map
6. 函数
7. defer 延迟调用
8. 函数进阶-变量作用域

#### <center>笔记</center>
1. > 数组
	- 数组是同一种数据类型元素的集合。在Go语言中，数组从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化。
	- 基本语法: 
		```
		var 数组变量名 [元素数量]元素类型

		// 定义一个长度为3 元素类型为int的数组
		var arr1 [3]int

		// 定义一个长度为3 元素类型为int的数组并初始化
		var arr2 [3]int = [3]int{1, 2, 3}

		// 声明一个长度自动检测数组并初始化
		var arr3 = [...]int{1, 2, 3}
		```
	- 数组的长度必须是常量，并且长度是 `数组类型` 的一部分。一旦定义，长度不能变。`[5]int` 和 `[10]int` 是不同的类型
	- 数组可以通过下标进行访问，下标是从 `0` 开始，最后一个元素下标是: `len-1`
2. > 多维数组
	- 多维数组的定义
		```
		// 定义一个二维数组
		arr1 := [3][2]int{ // 3表示数组中包含了几个数组，2表示每个子数组中包含几个元素
			{1, 2},
			{3, 4},
			{5, 6},
		}
		```
	- 多维数组的调用
		```
		fmt.Println(arr1[2][1]) // 输出数组中第三个子数组中的第二个值
		```
	- **注意事项**
		- 多维数组除了第一层，其他层不能使用 `...`
			```
			arr1 := [...][2]int{
				{1, 2},
				{3, 4},
				{5, 6},
			}		
			```
		- 
	- 
3. > 切片 (Slice)
	- `切片(Slice)` 是一个拥有相同类型元素的可变长度的序列。他是基于数组类型做的一层封装。
	- 切片属于 `引用类型`，它的内部结构包含`地址`、`大小`和`容量`。切片一般用于快速地操作一块数据集合。
	- 切片三要素：
    	- 地址: 切片中第一个元素指向的内存空间
    	- 大小: 切片中目前元素的个数			len()
    	- 容量: 底层数组最大能存放的元素的个数	  cap()
	- 切片的定义
		```
		var 切片变量名 []切片类型

		// 声明一个切片
		var one []int // one == nil

		// 声明一个切片并初始化
		var two = []int{1, 2, 3}
		```
	- 基于数组定义切片
		```
		// 定义一个数组
		var arr = [3]string{"one", "two", "thr"}

		// 对数组进行切片
		var thr = arr[:2]
		```
	- 切片范围
		```
		[:]   从头到尾
		[1:]  从第二位开始，一直到最后
		[:5]  从头开始，一直到索引自增为五的前一位
		[1:5] 从第二位开始，一直到索引自增为五的前一位
		```
	- 切片的扩容策略: 
        - 切片的容量不够时，并且在切片的长度小于1024的情况下，切片会自动扩充容量，扩充后的大小为扩充前容量的两倍。如果切片的长度大于等于1024的情况下，每次扩容的长度为扩容前切片长度的1/4
    - 使用copy函数复制切片
        - 由于切片是引用类型，所以当一个切片`b`复制了切片`a`之后，他们的内存地址也是一样的，所以修改切片`b`的时候切片`a`也会发生变化。
       	- Go语言内建的 `copy()` 函数可以迅速的将一个切片的数据复制到另一个切片空间中。
	- 从切片中删除元素
	    - Go语言中并没有删除切片元素的专用方法，我们可以使用切片本身的特性来删除元素
			```
			var six = []int{1, 2, 2, 3, 4, 5}
			fmt.Println(six)

			six = append(six[:2], six[3:]...) // 这里的...操作的意思是将 six[3:] 中的元素挨个拆开，然后挨个放入six中
			fmt.Println(six)
			```
		- 因为切片是引用类型，所以修改的就是其本身，使用append将需要保留的元素提取出来重新保存到该变量中
	- **注意事项**
    	- 切片的索引范围 `左包含右不包含`
4. > 数组和切片的区别
	```
	数组示例: [3]int
	切片示例: []int
	
	1. 切片不需要写长度，而数组定义必须填写长度
	```
5. > map
	- `map` 是一种无序的基于 `key-value` 的数据结构，Go语言中的 `map` 是引用类型，必须初始化才能使用。
    	- `map` 定义
    		```
    		map[键类型]值类型
    		```
	- 声明一个 `map`, 但不初始化
		```
		var T1 map[int]string
		```
  	- `map` 类型的变量默认初始值为`nil`，需要使用`make()`函数来分配内存
		```
		var T1 map[string]int
		T1 = make(map[string]int, 3) // 第一位为初始化的类型，第二位为容量
		```
  	- 声明一个 `map` 的同时初始化
		```
		var T1 = map[int]string{
			1: "one",
			2: "two",
			3: "thr",
		}
		```
	- 
6. > 函数
	- Go语言中支持函数、匿名函数和闭包，并且函数在Go语言中属于"一等公民"，可以赋值给变量，也可以作为参数。
	- 函数定义
		```
		func 函数名(参数)(返回值) {
			函数体
		}
		```
		- 函数名: 有字母、数字、下划线组成。但函数名的第一个字母不能是数字。在同一个包内，函数名也不能重复。
		- 参数: 参数由参数变量和参数类型组成，多个参数之间使用 `,` 分割。
		- 返回值: 返回值由返回值变量和其变量类型组成，也可以只写返回值的类型，多个返回值必须用 `()` 包裹，并用 `,` 分割
		- 函数体: 实现指定功能的代码块
    - 将函数赋值给变量
		```
		func T1() {
			fmt.Println(Hello world)
		}

		func main() {
			Test_1 := T1()
			Test_1()
		}
		```
	- 将函数作为参数
		```
		// 定义一个函数，接收两个整形参数，并返回他们的和
		func T1(a, b int) int {
			return a+b
		}

		// 定义一个函数，接收两个整形参数，并返回他们的差
		func T2(a, b int) int {
			return a-b
		}

		// 定义一个函数，接收两个整形参数(a,b)和一个函数参数(op)，并返回两个整形(a,b)的和，运算过程有函数参数(op)负责。
		/*
		只要函数声明的格式(参数和返回值)与函数参数(op)一致, 都可以传入当做函数参数(op)
		*/
		func T3(a, b int, op func(int, int) int) int{
			return op(a, b)
		}

		func main() {
			Test_1 := T3(1, 2, T1)
			fmt.Println(Test_1)
			Test_2 := T3(1, 2, T2)
			fmt.Println(Test_2)
		}
		```
7. > defer语句
	- Go语言中的 `defer` 语句会将其后面跟随的语句进行延迟处理。在 `defer` 归属的函数即将返回时，将延迟处理的语句按 `defer` 定义的逆序进行执行，也就是说，先被 `defer` 的语句最后执行，最后 `defer` 的语句，最先被执行。
	- 示例
		```
		fmt.Println("Start...") // 执行顺序 1
		defer fmt.Println(1)    // 执行顺序 5
		defer fmt.Println(2)    // 执行顺序 4
		defer fmt.Println(3)    // 执行顺序 3
		fmt.Println("Done...")  // 执行顺序 2
		```
	- 由于 `defer` 语句延迟调用的特性，所以 `defer` 语句能非常方便的处理资源释放问题。比如: 资源清理、文件关闭、解锁及记录时间等。
8. > 变量的作用域
	- 全局变量
    	- 全局变量是定义在函数外部的变量，它在程序整个运行期间内都有效。在函数中可以访问到全局变量。
	- 局部变量-函数内定义
		```
		func T1() {
			var a = 1 // a变量就是函数内定义的局部变量
			fmt.Println(a)
		}
		```
	- 局部变量-语句块内定义
		```
		func main() {
			// i变量就是语句块内定义的局部变量，只在该语句块中生效
			for i := 1; i <= 3; i++ {
				fmt.Println(i)
			}
		}
		```
	- `注意事项`
    	- 当在同一个包内`全局变量`和`局部变量`重名时，优先调用`局部变量`
9. 