#### <center>Day_03</center>

1. 指针
2. new 和 make
3. panic 和 recover
4. 自定义类型和类型别名
5. struct 结构体
6. 结构体的实例化
7. 构造函数和析构函数
8. init
9. 终端读写
10. 方法和接受者 (struct)
11. 任意类型添加方法
12. 结构体的匿名字段
13. 嵌套结构体
14. 结构体的"继承"
15. 结构体与JSON序列化
16. 结构体tag
17. 作业
	- 图书管理系统(写一个函数版写一个方法版)
	- 学员管理系统

#### <center>笔记</center>
1. > 指针
    - `指针` 和 `地址` 有什么区别?
    	- `地址` : 就是内存地址(用字节编码来描述的内存地址)
    	- `指针` : 指针是保存地址的变量
  	- `&` 和 `*`
    	- `&` : 表示取地址
    	- `*` : 表示根据地址取值
2. > new 和 make
	- `new` 是用来初始化值类型指针的
		```
		// 定义一个int类型的指针
		var T1 *int
		// 初始化int类型的指针(因为int是值类型所以用new)
		T1 = new(int)
		// 给T1赋值
		*T1 = 1
		```
	- `make` 是用来初始化引用类型的
3. > panic 和 recover
	- `panic` 是代码运行时的错误
	- `recover` 可以捕获 `panic` 报错，并且尝试将函数从当前的异常状态恢复
4. > 自定义类型和类型别名
	- 自定义类型
		```
		// NewInt 自定义类型: 基于Go语言的int类型，创建一个NewInt类型
		type NewInt int
		```
	- 类型别名
		```
		// MyInt 类型别名: 只存在代码编写过程中，代码编译之后根本不存在MyInt类型
		type MyInt = int
		```
5. > struct 结构体
	- 我们可以通过 `struct` 来定义自己的类型
	- 结构体的定义
		```
		// 使用 `type` 和 `struct` 关键字来定义结构体

		type 结构体类型名 struct {
			字段名 字段类型
			字段名 字段类型
			...
		}
		```
6. > 结构体的实例化
	- 基本实例化
		```
		// 如果初始化时没有给字段设置值，则默认使用对应类型的零值
		var 变量名 结构体类型名
		```
	- 实例化结构体，但其为结构体类型指针
		```
		var 变量名 new(结构体类型名)
		var 变量名 &结构体类型名
		```
  	- 结构体初始化
		```
		// 不省略字段名
		var 变量名 = 结构体类型名 {
			字段名: 值,
			字段名: 值,
			...
		}

		// 省略字段名，注意省略字段名的话需要按照结构体中字段声明顺序进行赋值
		var 变量名 = 结构体类型名 {
			值_1,
			值_2,
			...
		}
		```
7. > 构造函数和析构函数
	- Go语言的结构体没有 `构造函数` 和 `析构函数` ，但是我们可以根据Go语言的一些函数自己实现 `构造函数` 和 `析构函数`。
	- `构造函数`
    	- 析构函数的作用: 主要用来在创建对象时初始化对象
			```
			package main

			import "fmt"

			// 定义一个结构体
			type T1 struct {
				Name string
				Age  int
			}

			// 定义一个初始化结构体的方法
			/*
			创建T1类型的变量时，直接调用Test_1函数
			*/
			func Test_1(name string, age int) *T1 {
				return &T1{
					name,
					age,
				}
			}

			func main() {
				// 调用自定义析构函数
				one := Test_1("Smurfs", 21)
				fmt.Println(one)
			}
			```
	- `析构函数`
    	- 析构函数的作用: 在程序结束时自动执行(销毁一个对象)
    	- 可以使用 `defer` 来实现析构函数
8. > init
	- 在程序开始时自动执行
		```
		package main

		import "fmt"

		func init() {
			// 程序开始时自动执行
			fmt.Println("这个是init函数")
		}

		func main() {
			fmt.Println("这个是main函数")
		}
		```
9. > 终端读写 `Scan` 系列
	- Go语言 `fmt` 包下有 `fmt.Scan` 、 `fmt.Scanf` 、 `fmt.Scanln` 三个函数，可以在程序运行过程中从标准输入获取用户的输入。
	- `fmt.Scan`
    	- `Scan` 从标准输入扫描文本，读取由`空白符`分隔的值保存到传递给本函数的参数中，**换行符视为空白符**。
    	- 
	- `fmt.Scanf`
	- `fmt.Scanln`
10. > 方法和接受者 (struct)
	- Go语言中的 `方法(method)` 是一种作用于特定类型变量的函数。这种特定类型变量叫做 `接受者(Receiver)` 。接受者的概念就类似于其他其他语言中的 `this` 或 `self`。
	- 方法的定义格式如下:
		```
		func (接受者变量 接受者类型) 方法名(参数列表) (返回参数) {
			函数体
		}
		```
	- 方法和函数的区别
    	- 方法是某个具体的类型才能调用的方法
    	- 函数是谁都可以调用的
11. > 任意类型添加方法
	- 在Go语言中，接受者的类型可以使任何类型，不仅仅是结构体，任何类型都可以拥有方法。
	- **注意事项**: 非本地类型不能定义方法，也就是不能给别的包的类型定义方法
12. > 结构体的匿名字段
	- 结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段就称为匿名字段。
	- 匿名字段默认采用类型名作为字段名，结构体要求字段名称 `必须唯一`，因此一个结构体同种类型的匿名字段只能有一个。
13. > 嵌套结构体
	- 一个结构体中可以嵌套包含另一个结构体或者结构体指针
14. > 结构体的"继承"
	- 通过"继承"，子结构体也可以使用父结构体的方法
15. > 结构体字段的可见性
	- 结构体中字段大写开头表示可公开访问，小写表示私有(仅在定义当前结构体的包中可访问)
16. > 结构体与JSON序列化
	- `JSON(JavsScript Object Notation)`是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。JSON键值对是用来保存JS对象的一种方式，键/值对组合中的键名写在前面并用双引号 `""` 包裹，使用冒号 `:` 分割，然后紧接着值 `;` 多个键值之间使用英文 `,` 分割。
	- json格式数据示例:
		```
		{"Name":"T1","Age":18,"Sex":"男"}
		```
	- 序列化: 把编程语言里面的数据转换成 **JSON格式的字符串**
		```
		json.Marshal()
		```
	- 反序列化: 把满足**JSON格式的字符串** 转换成当前编程语言里面的对象
		```
		json.Unmarshal()
		```
	- **注意事项**: 
    	- 因为json对于自己定义的结构体来说属于外部的包，所以结构体的字段名首字母要大写
17. > 结构体tag
	- tag是结构体的元信息，可以在运行的时候通过反射的机制读取出来，例如json序列化的tag
	```
	type T1 struct {
		Name string `json:"name"`
		Age int		`json:"age"`
		Sex string	`json:"sex"`
	}
	```
18. 